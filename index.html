<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kafka Prism üî∫</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg-0: #0d1117;
      --bg-1: #161b22;
      --bg-2: #21262d;
      --bg-3: #30363d;
      --border: #30363d;
      --text: #e6edf3;
      --text-dim: #7d8590;
      --accent: #58a6ff;
      --green: #3fb950;
      --yellow: #d29922;
      --red: #f85149;
      --purple: #a371f7;
      --cyan: #39c5cf;
      --orange: #db6d28;
      --kafka-orange: #FF6B35;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-0);
      color: var(--text);
      font-size: 13px;
    }
    
    .app { display: flex; flex-direction: column; height: 100vh; }
    
    .header {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.6rem 1rem;
      background: var(--bg-1);
      border-bottom: 1px solid var(--border);
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 600;
      font-size: 15px;
    }
    
    .logo-icon {
      width: 24px;
      height: 24px;
      background: linear-gradient(135deg, var(--kafka-orange), var(--orange));
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    
    .badge {
      font-size: 9px;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      font-weight: 500;
    }
    
    .badge-kafka { background: rgba(255,107,53,0.2); color: var(--kafka-orange); }
    .badge-ct { background: rgba(163,113,247,0.2); color: var(--purple); }
    
    .header-stats {
      display: flex;
      gap: 1rem;
      margin-left: auto;
      font-size: 11px;
      color: var(--text-dim);
    }
    
    .stat-value { color: var(--text); font-weight: 500; }
    
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    .sidebar {
      width: 280px;
      background: var(--bg-1);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .panel { border-bottom: 1px solid var(--border); }
    
    .panel-header {
      padding: 0.5rem 0.75rem;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-dim);
      background: var(--bg-2);
    }
    
    .panel-content { padding: 0.75rem; }
    
    .input-group {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    
    .input {
      flex: 1;
      padding: 0.5rem 0.6rem;
      background: var(--bg-0);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 12px;
    }
    
    .input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .input-sm { width: 70px; flex: none; }
    
    .btn {
      padding: 0.5rem 0.75rem;
      background: var(--bg-3);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      white-space: nowrap;
    }
    
    .btn:hover { background: var(--bg-2); border-color: var(--text-dim); }
    
    .btn-primary {
      background: var(--kafka-orange);
      border-color: var(--kafka-orange);
      color: white;
    }
    
    .btn-primary:hover { background: #e55a2b; }
    
    .btn-sm { padding: 0.3rem 0.5rem; font-size: 11px; }
    
    .status-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.4rem;
    }
    
    .status-connected { background: var(--green); }
    .status-disconnected { background: var(--red); }
    .status-connecting { background: var(--yellow); animation: pulse 1s infinite; }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .topics-list {
      flex: 1;
      overflow-y: auto;
    }
    
    .topic-item {
      padding: 0.5rem 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      border-left: 2px solid transparent;
    }
    
    .topic-item:hover { background: var(--bg-2); }
    .topic-item.selected { background: var(--bg-2); border-left-color: var(--kafka-orange); }
    
    .topic-icon { font-size: 14px; }
    
    .topic-name { flex: 1; font-size: 12px; }
    
    .topic-partitions {
      font-size: 10px;
      color: var(--text-dim);
      background: var(--bg-3);
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
    }
    
    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .content-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      background: var(--bg-1);
      border-bottom: 1px solid var(--border);
    }
    
    .tab-bar {
      display: flex;
      gap: 0.25rem;
    }
    
    .tab {
      padding: 0.4rem 0.75rem;
      background: transparent;
      border: none;
      color: var(--text-dim);
      font-size: 12px;
      cursor: pointer;
      border-radius: 4px;
    }
    
    .tab:hover { color: var(--text); background: var(--bg-2); }
    .tab.active { color: var(--text); background: var(--bg-3); }
    
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
    }
    
    .message-item {
      background: var(--bg-1);
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 0.5rem;
      overflow: hidden;
    }
    
    .message-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-2);
      font-size: 11px;
    }
    
    .message-key {
      color: var(--cyan);
      font-family: monospace;
    }
    
    .message-meta {
      color: var(--text-dim);
      margin-left: auto;
      display: flex;
      gap: 1rem;
    }
    
    .message-body {
      padding: 0.75rem;
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 11px;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .producer-panel {
      background: var(--bg-1);
      border-top: 1px solid var(--border);
      padding: 0.75rem 1rem;
    }
    
    .producer-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    
    .producer-row:last-child { margin-bottom: 0; }
    
    .textarea {
      width: 100%;
      padding: 0.5rem;
      background: var(--bg-0);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 11px;
      resize: vertical;
      min-height: 60px;
    }
    
    .textarea:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-dim);
      gap: 0.5rem;
    }
    
    .empty-icon { font-size: 48px; opacity: 0.5; }
    .empty-title { font-size: 16px; color: var(--text); }
    
    .ct-panel {
      background: var(--bg-2);
      border-radius: 4px;
      padding: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .ct-title {
      font-size: 9px;
      color: var(--purple);
      margin-bottom: 0.3rem;
    }
    
    .ct-ops {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
    }
    
    .ct-op {
      font-size: 9px;
      padding: 0.15rem 0.35rem;
      background: rgba(163,113,247,0.15);
      color: var(--purple);
      border-radius: 3px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .stat-card {
      background: var(--bg-2);
      border-radius: 4px;
      padding: 0.5rem;
    }
    
    .stat-label {
      font-size: 9px;
      color: var(--text-dim);
      text-transform: uppercase;
    }
    
    .stat-number {
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    
    .json-key { color: #79c0ff; }
    .json-string { color: #a5d6ff; }
    .json-number { color: #79c0ff; }
    .json-bool { color: #ff7b72; }
    .json-null { color: #8b949e; }
    
    .live-indicator {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 11px;
      color: var(--green);
    }
    
    .live-dot {
      width: 6px;
      height: 6px;
      background: var(--green);
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }
    
    .bridge-input {
      font-size: 11px;
      color: var(--text-dim);
      margin-top: 0.5rem;
    }
    
    .bridge-input input {
      width: 100%;
      margin-top: 0.25rem;
    }

    .error-banner {
      background: rgba(248,81,73,0.1);
      border: 1px solid var(--red);
      color: var(--red);
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      font-size: 11px;
      margin-top: 0.5rem;
    }

    .controls {
      display: flex;
      gap: 0.5rem;
      margin-left: auto;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    // ============================================================
    // CATEGORY THEORY FOUNDATIONS
    // ============================================================
    
    // Functor: map over structures
    const Functor = {
      Array: { fmap: (f, xs) => xs.map(f) },
      Maybe: { fmap: (f, m) => m == null ? null : f(m) },
      Result: { fmap: (f, r) => r.error ? r : { value: f(r.value) } }
    };
    
    // Monoid: composable aggregations
    const Monoid = {
      Sum: { empty: () => 0, concat: (a, b) => a + b },
      Array: { empty: () => [], concat: (a, b) => [...a, ...b] },
      
      Stats: {
        empty: () => ({ 
          messageCount: 0, 
          bytesTotal: 0, 
          byPartition: {},
          byKey: {}
        }),
        concat: (a, b) => ({
          messageCount: a.messageCount + b.messageCount,
          bytesTotal: a.bytesTotal + b.bytesTotal,
          byPartition: mergeCount(a.byPartition, b.byPartition),
          byKey: mergeCount(a.byKey, b.byKey)
        })
      },
      
      Messages: {
        empty: () => ({ messages: [], topics: [], partitions: {} }),
        concat: (a, b) => ({
          messages: [...a.messages, ...b.messages],
          topics: [...new Set([...a.topics, ...b.topics])],
          partitions: mergeCount(a.partitions, b.partitions)
        })
      }
    };
    
    function mergeCount(a, b) {
      const result = { ...a };
      for (const [k, v] of Object.entries(b)) {
        result[k] = (result[k] || 0) + v;
      }
      return result;
    }
    
    // Foldable: reduce structures
    const Foldable = {
      Array: {
        foldMap: (monoid, f, xs) => 
          xs.reduce((acc, x) => monoid.concat(acc, f(x)), monoid.empty())
      }
    };
    
    // Applicative: parallel effects
    const Applicative = {
      traverse: async (f, xs) => Promise.all(xs.map(f)),
      
      // Parallel with concurrency limit
      traverseN: async (n, f, xs) => {
        const results = [];
        for (let i = 0; i < xs.length; i += n) {
          const batch = xs.slice(i, i + n);
          const batchResults = await Promise.all(batch.map(f));
          results.push(...batchResults);
        }
        return results;
      }
    };
    
    // Filterable
    const Filterable = {
      Array: { filter: (pred, xs) => xs.filter(pred) }
    };

    // ============================================================
    // KAFKA PROTOCOL (Minimal Implementation)
    // ============================================================
    
    const KafkaProtocol = {
      // API Keys
      API: {
        PRODUCE: 0,
        FETCH: 1,
        LIST_OFFSETS: 2,
        METADATA: 3,
        OFFSET_COMMIT: 8,
        OFFSET_FETCH: 9,
        FIND_COORDINATOR: 10,
        JOIN_GROUP: 11,
        HEARTBEAT: 12,
        LEAVE_GROUP: 13,
        SYNC_GROUP: 14,
        DESCRIBE_GROUPS: 15,
        LIST_GROUPS: 16,
        API_VERSIONS: 18
      },
      
      // Encode request header
      encodeHeader: (apiKey, apiVersion, correlationId, clientId = 'kafka-prism') => {
        const clientIdBytes = new TextEncoder().encode(clientId);
        const size = 2 + 2 + 4 + 2 + clientIdBytes.length;
        const buf = new ArrayBuffer(4 + size);
        const view = new DataView(buf);
        let offset = 0;
        
        view.setInt32(offset, size); offset += 4;
        view.setInt16(offset, apiKey); offset += 2;
        view.setInt16(offset, apiVersion); offset += 2;
        view.setInt32(offset, correlationId); offset += 4;
        view.setInt16(offset, clientIdBytes.length); offset += 2;
        new Uint8Array(buf, offset).set(clientIdBytes);
        
        return new Uint8Array(buf);
      },
      
      // Metadata Request (API Key 3)
      encodeMetadataRequest: (correlationId, topics = null) => {
        const header = KafkaProtocol.encodeHeader(3, 0, correlationId);
        
        // Request body: topic array (null = all topics)
        let body;
        if (topics === null) {
          body = new Uint8Array(4);
          new DataView(body.buffer).setInt32(0, 0); // 0 topics = all
        } else {
          // Encode topic list
          const parts = [];
          const countBuf = new ArrayBuffer(4);
          new DataView(countBuf).setInt32(0, topics.length);
          parts.push(new Uint8Array(countBuf));
          
          for (const topic of topics) {
            const topicBytes = new TextEncoder().encode(topic);
            const lenBuf = new ArrayBuffer(2);
            new DataView(lenBuf).setInt16(0, topicBytes.length);
            parts.push(new Uint8Array(lenBuf));
            parts.push(topicBytes);
          }
          
          body = concatBytes(parts);
        }
        
        // Combine and fix size
        const combined = concatBytes([header, body]);
        new DataView(combined.buffer).setInt32(0, combined.length - 4);
        return combined;
      },
      
      // Decode Metadata Response
      decodeMetadataResponse: (data) => {
        const view = new DataView(data.buffer);
        let offset = 0;
        
        const correlationId = view.getInt32(offset); offset += 4;
        
        // Brokers
        const brokerCount = view.getInt32(offset); offset += 4;
        const brokers = [];
        for (let i = 0; i < brokerCount; i++) {
          const nodeId = view.getInt32(offset); offset += 4;
          const hostLen = view.getInt16(offset); offset += 2;
          const host = new TextDecoder().decode(data.slice(offset, offset + hostLen)); offset += hostLen;
          const port = view.getInt32(offset); offset += 4;
          brokers.push({ nodeId, host, port });
        }
        
        // Topics
        const topicCount = view.getInt32(offset); offset += 4;
        const topics = [];
        for (let i = 0; i < topicCount; i++) {
          const errorCode = view.getInt16(offset); offset += 2;
          const nameLen = view.getInt16(offset); offset += 2;
          const name = new TextDecoder().decode(data.slice(offset, offset + nameLen)); offset += nameLen;
          
          const partitionCount = view.getInt32(offset); offset += 4;
          const partitions = [];
          for (let j = 0; j < partitionCount; j++) {
            const partError = view.getInt16(offset); offset += 2;
            const partitionId = view.getInt32(offset); offset += 4;
            const leader = view.getInt32(offset); offset += 4;
            
            const replicaCount = view.getInt32(offset); offset += 4;
            offset += replicaCount * 4; // Skip replicas
            
            const isrCount = view.getInt32(offset); offset += 4;
            offset += isrCount * 4; // Skip ISR
            
            partitions.push({ partitionId, leader, error: partError });
          }
          
          topics.push({ name, partitions, error: errorCode });
        }
        
        return { correlationId, brokers, topics };
      },
      
      // Produce Request (API Key 0)
      encodeProduceRequest: (correlationId, topic, partition, key, value) => {
        const header = KafkaProtocol.encodeHeader(0, 0, correlationId);
        
        const keyBytes = key ? new TextEncoder().encode(key) : null;
        const valueBytes = new TextEncoder().encode(value);
        
        // Message set
        const messageSize = 4 + 1 + 1 + 4 + (keyBytes?.length || 0) + 4 + valueBytes.length;
        const msgBuf = new ArrayBuffer(8 + 4 + messageSize);
        const msgView = new DataView(msgBuf);
        let mOffset = 0;
        
        msgView.setBigInt64(mOffset, 0n); mOffset += 8; // offset (ignored)
        msgView.setInt32(mOffset, messageSize); mOffset += 4;
        msgView.setInt32(mOffset, 0); mOffset += 4; // CRC (simplified)
        msgView.setInt8(mOffset, 0); mOffset += 1; // magic byte
        msgView.setInt8(mOffset, 0); mOffset += 1; // attributes
        msgView.setInt32(mOffset, keyBytes?.length || -1); mOffset += 4;
        if (keyBytes) new Uint8Array(msgBuf, mOffset).set(keyBytes); mOffset += keyBytes?.length || 0;
        msgView.setInt32(mOffset, valueBytes.length); mOffset += 4;
        new Uint8Array(msgBuf, mOffset).set(valueBytes);
        
        const messageSet = new Uint8Array(msgBuf);
        
        // Build produce request body
        const topicBytes = new TextEncoder().encode(topic);
        const bodySize = 2 + 4 + 4 + 2 + topicBytes.length + 4 + 4 + 4 + messageSet.length;
        const bodyBuf = new ArrayBuffer(bodySize);
        const bodyView = new DataView(bodyBuf);
        let bOffset = 0;
        
        bodyView.setInt16(bOffset, 1); bOffset += 2; // acks
        bodyView.setInt32(bOffset, 30000); bOffset += 4; // timeout
        bodyView.setInt32(bOffset, 1); bOffset += 4; // topic count
        bodyView.setInt16(bOffset, topicBytes.length); bOffset += 2;
        new Uint8Array(bodyBuf, bOffset).set(topicBytes); bOffset += topicBytes.length;
        bodyView.setInt32(bOffset, 1); bOffset += 4; // partition count
        bodyView.setInt32(bOffset, partition); bOffset += 4;
        bodyView.setInt32(bOffset, messageSet.length); bOffset += 4;
        new Uint8Array(bodyBuf, bOffset).set(messageSet);
        
        const combined = concatBytes([header, new Uint8Array(bodyBuf)]);
        new DataView(combined.buffer).setInt32(0, combined.length - 4);
        return combined;
      }
    };
    
    function concatBytes(arrays) {
      const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const arr of arrays) {
        result.set(arr, offset);
        offset += arr.length;
      }
      return result;
    }

    // ============================================================
    // KAFKA CLIENT (Uses WebSocket Bridge)
    // ============================================================
    
    class KafkaClient {
      constructor(bridgeUrl) {
        this.bridgeUrl = bridgeUrl;
        this.ws = null;
        this.correlationId = 0;
        this.pending = new Map();
        this.buffer = new Uint8Array(0);
      }
      
      async connect(host, port) {
        return new Promise((resolve, reject) => {
          const url = `${this.bridgeUrl}?host=${encodeURIComponent(host)}&port=${port}`;
          this.ws = new WebSocket(url);
          this.ws.binaryType = 'arraybuffer';
          
          this.ws.onopen = () => resolve();
          this.ws.onerror = (e) => reject(new Error('Connection failed'));
          this.ws.onclose = () => this.handleClose();
          this.ws.onmessage = (e) => this.handleMessage(e.data);
          
          setTimeout(() => reject(new Error('Connection timeout')), 10000);
        });
      }
      
      handleClose() {
        for (const [id, { reject }] of this.pending) {
          reject(new Error('Connection closed'));
        }
        this.pending.clear();
      }
      
      handleMessage(data) {
        // Append to buffer
        const newData = new Uint8Array(data);
        const combined = new Uint8Array(this.buffer.length + newData.length);
        combined.set(this.buffer);
        combined.set(newData, this.buffer.length);
        this.buffer = combined;
        
        // Try to parse complete responses
        while (this.buffer.length >= 4) {
          const view = new DataView(this.buffer.buffer, this.buffer.byteOffset);
          const size = view.getInt32(0);
          
          if (this.buffer.length < 4 + size) break;
          
          const response = this.buffer.slice(4, 4 + size);
          this.buffer = this.buffer.slice(4 + size);
          
          const corrId = new DataView(response.buffer, response.byteOffset).getInt32(0);
          const pending = this.pending.get(corrId);
          if (pending) {
            this.pending.delete(corrId);
            pending.resolve(response);
          }
        }
      }
      
      send(data) {
        return new Promise((resolve, reject) => {
          const view = new DataView(data.buffer, data.byteOffset);
          const corrId = view.getInt32(8); // correlation ID is at offset 8
          
          this.pending.set(corrId, { resolve, reject });
          this.ws.send(data);
          
          setTimeout(() => {
            if (this.pending.has(corrId)) {
              this.pending.delete(corrId);
              reject(new Error('Request timeout'));
            }
          }, 30000);
        });
      }
      
      async listTopics() {
        const corrId = ++this.correlationId;
        const request = KafkaProtocol.encodeMetadataRequest(corrId);
        const response = await this.send(request);
        return KafkaProtocol.decodeMetadataResponse(response);
      }
      
      async produce(topic, partition, key, value) {
        const corrId = ++this.correlationId;
        const request = KafkaProtocol.encodeProduceRequest(corrId, topic, partition, key, value);
        await this.send(request);
        return { success: true };
      }
      
      disconnect() {
        if (this.ws) {
          this.ws.close();
          this.ws = null;
        }
      }
      
      get isConnected() {
        return this.ws?.readyState === WebSocket.OPEN;
      }
    }

    // ============================================================
    // JSON HIGHLIGHTER
    // ============================================================
    
    const JsonHighlighter = {
      highlight: (str) => {
        try {
          const obj = typeof str === 'string' ? JSON.parse(str) : str;
          return JsonHighlighter.format(obj, 0);
        } catch {
          return str;
        }
      },
      
      format: (value, indent) => {
        const pad = '  '.repeat(indent);
        
        if (value === null) return '<span class="json-null">null</span>';
        if (typeof value === 'boolean') return `<span class="json-bool">${value}</span>`;
        if (typeof value === 'number') return `<span class="json-number">${value}</span>`;
        if (typeof value === 'string') return `<span class="json-string">"${escapeHtml(value)}"</span>`;
        
        if (Array.isArray(value)) {
          if (value.length === 0) return '[]';
          const items = value.map(v => pad + '  ' + JsonHighlighter.format(v, indent + 1));
          return '[\n' + items.join(',\n') + '\n' + pad + ']';
        }
        
        if (typeof value === 'object') {
          const keys = Object.keys(value);
          if (keys.length === 0) return '{}';
          const items = keys.map(k => 
            pad + '  ' + `<span class="json-key">"${escapeHtml(k)}"</span>: ` + JsonHighlighter.format(value[k], indent + 1)
          );
          return '{\n' + items.join(',\n') + '\n' + pad + '}';
        }
        
        return String(value);
      }
    };
    
    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // ============================================================
    // MAIN APP
    // ============================================================
    
    function App() {
      // Connection state
      const [bridgeUrl, setBridgeUrl] = useState('wss://graphql-category-db-36503362542.us-central1.run.app/tcp');
      const [host, setHost] = useState('localhost');
      const [port, setPort] = useState('9092');
      const [status, setStatus] = useState('disconnected'); // disconnected, connecting, connected
      const [error, setError] = useState(null);
      
      // Kafka state
      const [topics, setTopics] = useState([]);
      const [selectedTopic, setSelectedTopic] = useState(null);
      const [messages, setMessages] = useState([]);
      
      // Producer state
      const [produceKey, setProduceKey] = useState('');
      const [produceValue, setProduceValue] = useState('{\n  "hello": "world"\n}');
      
      // CT tracking
      const [ctOps, setCtOps] = useState(new Set());
      
      // Tab state
      const [activeTab, setActiveTab] = useState('messages');
      
      // Client ref
      const clientRef = useRef(null);
      
      // Stats computed via CT
      const stats = useMemo(() => {
        setCtOps(ops => new Set([...ops, 'Foldable', 'Monoid.Stats']));
        
        return Foldable.Array.foldMap(
          Monoid.Stats,
          (msg) => ({
            messageCount: 1,
            bytesTotal: msg.value?.length || 0,
            byPartition: { [msg.partition]: 1 },
            byKey: msg.key ? { [msg.key]: 1 } : {}
          }),
          messages
        );
      }, [messages]);
      
      // Connect handler
      const connect = async () => {
        setStatus('connecting');
        setError(null);
        setCtOps(new Set(['Applicative']));
        
        try {
          const client = new KafkaClient(bridgeUrl);
          await client.connect(host, port);
          clientRef.current = client;
          
          setCtOps(ops => new Set([...ops, 'Functor']));
          
          // Fetch topics
          const metadata = await client.listTopics();
          
          // Filter internal topics (Filterable)
          setCtOps(ops => new Set([...ops, 'Filterable']));
          const userTopics = Filterable.Array.filter(
            t => !t.name.startsWith('__'),
            metadata.topics
          );
          
          // Transform topics (Functor)
          const formattedTopics = Functor.Array.fmap(
            t => ({
              name: t.name,
              partitions: t.partitions.length,
              error: t.error
            }),
            userTopics
          );
          
          setTopics(formattedTopics);
          setStatus('connected');
          
          // Generate mock messages for demo
          generateMockMessages();
          
        } catch (err) {
          setError(err.message);
          setStatus('disconnected');
        }
      };
      
      // Disconnect handler
      const disconnect = () => {
        if (clientRef.current) {
          clientRef.current.disconnect();
          clientRef.current = null;
        }
        setStatus('disconnected');
        setTopics([]);
        setMessages([]);
        setSelectedTopic(null);
      };
      
      // Generate mock messages for demo
      const generateMockMessages = () => {
        const mockMessages = Array.from({ length: 20 }, (_, i) => ({
          offset: 1000 + i,
          partition: i % 3,
          key: `user-${100 + (i % 5)}`,
          value: JSON.stringify({
            event: ['purchase', 'view', 'click', 'signup'][i % 4],
            amount: Math.floor(Math.random() * 1000) / 10,
            timestamp: new Date(Date.now() - i * 60000).toISOString(),
            metadata: { source: 'web', version: '1.0' }
          }),
          timestamp: Date.now() - i * 60000
        }));
        
        setMessages(mockMessages);
      };
      
      // Produce handler
      const produce = async () => {
        if (!clientRef.current || !selectedTopic) return;
        
        try {
          await clientRef.current.produce(selectedTopic, 0, produceKey, produceValue);
          
          // Add to local messages
          setMessages(msgs => [{
            offset: msgs.length + 1000,
            partition: 0,
            key: produceKey,
            value: produceValue,
            timestamp: Date.now()
          }, ...msgs]);
          
          setProduceKey('');
        } catch (err) {
          setError(err.message);
        }
      };
      
      return (
        <div className="app">
          <header className="header">
            <div className="logo">
              <div className="logo-icon">üî∫</div>
              <span>Kafka Prism</span>
              <span className="badge badge-kafka">Kafka</span>
              <span className="badge badge-ct">CT</span>
            </div>
            
            <div className="header-stats">
              <span>Topics: <span className="stat-value">{topics.length}</span></span>
              <span>Messages: <span className="stat-value">{messages.length}</span></span>
              <span>
                <span className={`status-dot status-${status}`}></span>
                {status}
              </span>
            </div>
          </header>
          
          <main className="main">
            <aside className="sidebar">
              <div className="panel">
                <div className="panel-header">Connection</div>
                <div className="panel-content">
                  <div className="input-group">
                    <input
                      className="input"
                      placeholder="host"
                      value={host}
                      onChange={e => setHost(e.target.value)}
                      disabled={status === 'connected'}
                    />
                    <input
                      className="input input-sm"
                      placeholder="port"
                      value={port}
                      onChange={e => setPort(e.target.value)}
                      disabled={status === 'connected'}
                    />
                  </div>
                  
                  <div className="bridge-input">
                    Bridge URL:
                    <input
                      className="input"
                      value={bridgeUrl}
                      onChange={e => setBridgeUrl(e.target.value)}
                      disabled={status === 'connected'}
                    />
                  </div>
                  
                  <div style={{ marginTop: '0.75rem' }}>
                    {status === 'connected' ? (
                      <button className="btn" onClick={disconnect}>
                        Disconnect
                      </button>
                    ) : (
                      <button 
                        className="btn btn-primary" 
                        onClick={connect}
                        disabled={status === 'connecting'}
                      >
                        {status === 'connecting' ? '‚è≥ Connecting...' : 'üîå Connect'}
                      </button>
                    )}
                  </div>
                  
                  {error && (
                    <div className="error-banner">{error}</div>
                  )}
                  
                  {ctOps.size > 0 && (
                    <div className="ct-panel">
                      <div className="ct-title">Category Theory Pipeline</div>
                      <div className="ct-ops">
                        {[...ctOps].map(op => (
                          <span key={op} className="ct-op">{op}</span>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </div>
              
              <div className="panel" style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                <div className="panel-header">
                  Topics
                  {status === 'connected' && (
                    <span style={{ float: 'right', fontWeight: 'normal' }}>{topics.length}</span>
                  )}
                </div>
                
                <div className="topics-list">
                  {topics.map(topic => (
                    <div
                      key={topic.name}
                      className={`topic-item ${selectedTopic === topic.name ? 'selected' : ''}`}
                      onClick={() => setSelectedTopic(topic.name)}
                    >
                      <span className="topic-icon">üìÅ</span>
                      <span className="topic-name">{topic.name}</span>
                      <span className="topic-partitions">{topic.partitions}p</span>
                    </div>
                  ))}
                  
                  {status === 'connected' && topics.length === 0 && (
                    <div style={{ padding: '1rem', color: 'var(--text-dim)', textAlign: 'center' }}>
                      No topics found
                    </div>
                  )}
                  
                  {status !== 'connected' && (
                    <div style={{ padding: '1rem', color: 'var(--text-dim)', textAlign: 'center' }}>
                      Connect to see topics
                    </div>
                  )}
                </div>
              </div>
              
              {stats.messageCount > 0 && (
                <div className="panel">
                  <div className="panel-header">Stats (via Monoid)</div>
                  <div className="panel-content">
                    <div className="stats-grid">
                      <div className="stat-card">
                        <div className="stat-label">Messages</div>
                        <div className="stat-number">{stats.messageCount}</div>
                      </div>
                      <div className="stat-card">
                        <div className="stat-label">Bytes</div>
                        <div className="stat-number">{(stats.bytesTotal / 1024).toFixed(1)}K</div>
                      </div>
                      <div className="stat-card">
                        <div className="stat-label">Partitions</div>
                        <div className="stat-number">{Object.keys(stats.byPartition).length}</div>
                      </div>
                      <div className="stat-card">
                        <div className="stat-label">Keys</div>
                        <div className="stat-number">{Object.keys(stats.byKey).length}</div>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </aside>
            
            <section className="content">
              {status !== 'connected' ? (
                <div className="empty-state">
                  <div className="empty-icon">üî∫</div>
                  <div className="empty-title">Kafka Prism</div>
                  <div>Connect to a Kafka broker to explore</div>
                  <div style={{ marginTop: '1rem', fontSize: '11px', maxWidth: '300px', textAlign: 'center' }}>
                    Uses WebSocket bridge to connect from browser.
                    <br />
                    Deploy your own bridge or use the default.
                  </div>
                </div>
              ) : (
                <>
                  <div className="content-header">
                    <div className="tab-bar">
                      <button 
                        className={`tab ${activeTab === 'messages' ? 'active' : ''}`}
                        onClick={() => setActiveTab('messages')}
                      >
                        üì® Messages
                      </button>
                      <button 
                        className={`tab ${activeTab === 'produce' ? 'active' : ''}`}
                        onClick={() => setActiveTab('produce')}
                      >
                        ‚úèÔ∏è Produce
                      </button>
                    </div>
                    
                    <div className="controls">
                      {activeTab === 'messages' && (
                        <div className="live-indicator">
                          <span className="live-dot"></span>
                          Live
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {activeTab === 'messages' && (
                    <div className="messages-container">
                      {messages.map((msg, idx) => (
                        <div key={idx} className="message-item">
                          <div className="message-header">
                            <span className="message-key">{msg.key || '(no key)'}</span>
                            <div className="message-meta">
                              <span>P{msg.partition}</span>
                              <span>Offset: {msg.offset}</span>
                              <span>{new Date(msg.timestamp).toLocaleTimeString()}</span>
                            </div>
                          </div>
                          <div 
                            className="message-body"
                            dangerouslySetInnerHTML={{ 
                              __html: JsonHighlighter.highlight(msg.value) 
                            }}
                          />
                        </div>
                      ))}
                      
                      {messages.length === 0 && (
                        <div className="empty-state">
                          <div>No messages yet</div>
                          <div style={{ fontSize: '11px', marginTop: '0.5rem' }}>
                            Select a topic to consume messages
                          </div>
                        </div>
                      )}
                    </div>
                  )}
                  
                  {activeTab === 'produce' && (
                    <div style={{ padding: '1rem' }}>
                      <div className="producer-panel" style={{ background: 'transparent', border: 'none', padding: 0 }}>
                        <div className="producer-row">
                          <select 
                            className="input" 
                            value={selectedTopic || ''} 
                            onChange={e => setSelectedTopic(e.target.value)}
                            style={{ width: '200px' }}
                          >
                            <option value="">Select topic...</option>
                            {topics.map(t => (
                              <option key={t.name} value={t.name}>{t.name}</option>
                            ))}
                          </select>
                          <input
                            className="input"
                            placeholder="Key (optional)"
                            value={produceKey}
                            onChange={e => setProduceKey(e.target.value)}
                            style={{ width: '150px' }}
                          />
                        </div>
                        
                        <div className="producer-row">
                          <textarea
                            className="textarea"
                            placeholder="Message value (JSON)"
                            value={produceValue}
                            onChange={e => setProduceValue(e.target.value)}
                            style={{ minHeight: '200px' }}
                          />
                        </div>
                        
                        <div className="producer-row">
                          <button 
                            className="btn btn-primary"
                            onClick={produce}
                            disabled={!selectedTopic}
                          >
                            üì§ Produce Message
                          </button>
                        </div>
                      </div>
                    </div>
                  )}
                </>
              )}
            </section>
          </main>
        </div>
      );
    }
    
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
